Test Workloads:  Workload E: Our goal for this workload was to allocate blocks on sizes of power <= 2 ^ 7 (128). We repeated this process for 150 times, for 50 bytes. We set up error checks to notify the user in case the workload goes out of bounds. We also used << 1 in order to increment on powers of 2. Which takes us to another point, for some reason, when using << 1, the program is supposed to increment the byte size by a power of 2, whoever, during our testing, we discovered that it was incrementing on powers of 2 Ð 2. For example, our limit was 128 (<=128) and the bite started at 2 (2 ^ 1); in theory we should have gotten 2^1, 2^2, 2^3 É. Until 2^6. However, the results captured during testing were: 0, 2a, 6, 14, 30, 62, 126. Although the workload worked and we reached our goal, we would have liked to find out what was causing the values to print differently. Workload F:To be honest, we had a more ambitious plan, but we got really close to the deadline time and changed our mind. The goal was to use mymalloc to allocate 64 blocks, and then use myfree to free every other block until reaching 1 block. We picked 64 blocks, because it would basically allocate 64 blocks, free 32, then free 16 and so on until reaching the value of 2 ^ 0 which would be the last block. The additional idea behind this workload was to test our merging process. Since it would basically free every other block, we wanted myfree to be able to merge every two consecutive free blocks in order to avoid data fragmentation. However, we ended changing Workload F to work the opposite way of Workload E. Basically it will start allocating the biggest block (64) and free it and going down the hill on powers of 2. Same concept as E, just in the opposite order. We enjoy working on this project a lot, and wished we could have had more time left to provide more creative ways to test our program.  